{"version":3,"file":"lib.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://texLineBreak_/webpack/universalModuleDefinition","webpack://texLineBreak_/./node_modules/hypher/lib/hypher.js","webpack://texLineBreak_/./src/helpers.ts","webpack://texLineBreak_/./src/html.ts","webpack://texLineBreak_/./src/hyphenate.ts","webpack://texLineBreak_/./src/index.ts","webpack://texLineBreak_/./src/layout.ts","webpack://texLineBreak_/./src/util/dom-text-measurer.ts","webpack://texLineBreak_/./src/util/range.ts","webpack://texLineBreak_/webpack/bootstrap","webpack://texLineBreak_/webpack/before-startup","webpack://texLineBreak_/webpack/startup","webpack://texLineBreak_/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"texLineBreak_lib\"] = factory();\n\telse\n\t\troot[\"texLineBreak_lib\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","/**\n * @constructor\n * @param {!{patterns: !Object, leftmin: !number, rightmin: !number}} language The language pattern file. Compatible with Hyphenator.js.\n */\nfunction Hypher(language) {\n    var exceptions = [],\n        i = 0;\n    /**\n     * @type {!Hypher.TrieNode}\n     */\n    this.trie = this.createTrie(language['patterns']);\n\n    /**\n     * @type {!number}\n     * @const\n     */\n    this.leftMin = language['leftmin'];\n\n    /**\n     * @type {!number}\n     * @const\n     */\n    this.rightMin = language['rightmin'];\n\n    /**\n     * @type {!Object.<string, !Array.<string>>}\n     */\n    this.exceptions = {};\n\n    if (language['exceptions']) {\n        exceptions = language['exceptions'].split(/,\\s?/g);\n\n        for (; i < exceptions.length; i += 1) {\n            this.exceptions[exceptions[i].replace(/\\u2027/g, '').toLowerCase()] = new RegExp('(' + exceptions[i].split('\\u2027').join(')(') + ')', 'i');\n        }\n    }\n}\n\n/**\n * @typedef {{_points: !Array.<number>}}\n */\nHypher.TrieNode;\n\n/**\n * Creates a trie from a language pattern.\n * @private\n * @param {!Object} patternObject An object with language patterns.\n * @return {!Hypher.TrieNode} An object trie.\n */\nHypher.prototype.createTrie = function (patternObject) {\n    var size = 0,\n        i = 0,\n        c = 0,\n        p = 0,\n        chars = null,\n        points = null,\n        codePoint = null,\n        t = null,\n        tree = {\n            _points: []\n        },\n        patterns;\n\n    for (size in patternObject) {\n        if (patternObject.hasOwnProperty(size)) {\n            patterns = patternObject[size].match(new RegExp('.{1,' + (+size) + '}', 'g'));\n\n            for (i = 0; i < patterns.length; i += 1) {\n                chars = patterns[i].replace(/[0-9]/g, '').split('');\n                points = patterns[i].split(/\\D/);\n                t = tree;\n\n                for (c = 0; c < chars.length; c += 1) {\n                    codePoint = chars[c].charCodeAt(0);\n\n                    if (!t[codePoint]) {\n                        t[codePoint] = {};\n                    }\n                    t = t[codePoint];\n                }\n\n                t._points = [];\n\n                for (p = 0; p < points.length; p += 1) {\n                    t._points[p] = points[p] || 0;\n                }\n            }\n        }\n    }\n    return tree;\n};\n\n/**\n * Hyphenates a text.\n *\n * @param {!string} str The text to hyphenate.\n * @return {!string} The same text with soft hyphens inserted in the right positions.\n */\nHypher.prototype.hyphenateText = function (str, minLength) {\n    minLength = minLength || 4;\n\n    // Regexp(\"\\b\", \"g\") splits on word boundaries,\n    // compound separators and ZWNJ so we don't need\n    // any special cases for those characters. Unfortunately\n    // it does not support unicode word boundaries, so\n    // we implement it manually.\n    var words = str.split(/([a-zA-Z0-9_\\u0027\\u00AD\\u00DF-\\u00EA\\u00EB\\u00EC-\\u00EF\\u00F1-\\u00F6\\u00F8-\\u00FD\\u0101\\u0103\\u0105\\u0107\\u0109\\u010D\\u010F\\u0111\\u0113\\u0117\\u0119\\u011B\\u011D\\u011F\\u0123\\u0125\\u012B\\u012F\\u0131\\u0135\\u0137\\u013C\\u013E\\u0142\\u0144\\u0146\\u0148\\u0151\\u0153\\u0155\\u0159\\u015B\\u015D\\u015F\\u0161\\u0165\\u016B\\u016D\\u016F\\u0171\\u0173\\u017A\\u017C\\u017E\\u017F\\u0219\\u021B\\u02BC\\u0390\\u03AC-\\u03CE\\u03F2\\u0401\\u0410-\\u044F\\u0451\\u0454\\u0456\\u0457\\u045E\\u0491\\u0531-\\u0556\\u0561-\\u0587\\u0902\\u0903\\u0905-\\u090B\\u090E-\\u0910\\u0912\\u0914-\\u0928\\u092A-\\u0939\\u093E-\\u0943\\u0946-\\u0948\\u094A-\\u094D\\u0982\\u0983\\u0985-\\u098B\\u098F\\u0990\\u0994-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BE-\\u09C3\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u0A02\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A14-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A82\\u0A83\\u0A85-\\u0A8B\\u0A8F\\u0A90\\u0A94-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABE-\\u0AC3\\u0AC7\\u0AC8\\u0ACB-\\u0ACD\\u0B02\\u0B03\\u0B05-\\u0B0B\\u0B0F\\u0B10\\u0B14-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3E-\\u0B43\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B57\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB5\\u0BB7-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C02\\u0C03\\u0C05-\\u0C0B\\u0C0E-\\u0C10\\u0C12\\u0C14-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3E-\\u0C43\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C82\\u0C83\\u0C85-\\u0C8B\\u0C8E-\\u0C90\\u0C92\\u0C94-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBE-\\u0CC3\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D28\\u0D2A-\\u0D39\\u0D3E-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u1F00-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB2-\\u1FB4\\u1FB6\\u1FB7\\u1FBD\\u1FBF\\u1FC2-\\u1FC4\\u1FC6\\u1FC7\\u1FD2\\u1FD3\\u1FD6\\u1FD7\\u1FE2-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6\\u1FF7\\u200D\\u2019]+)/gi);\n\n    for (var i = 0; i < words.length; i += 1) {\n        if (words[i].indexOf('/') !== -1) {\n            // Don't insert a zero width space if the slash is at the beginning or end\n            // of the text, or right after or before a space.\n            if (i !== 0 && i !== words.length - 1 && !(/\\s+\\/|\\/\\s+/.test(words[i]))) {\n                words[i] += '\\u200B';\n            }\n        } else if (words[i].length > minLength) {\n            words[i] = this.hyphenate(words[i]).join('\\u00AD');\n        }\n    }\n    return words.join('');\n};\n\n/**\n * Hyphenates a word.\n *\n * @param {!string} word The word to hyphenate\n * @return {!Array.<!string>} An array of word fragments indicating valid hyphenation points.\n */\nHypher.prototype.hyphenate = function (word) {\n    var characters,\n        characterPoints = [],\n        originalCharacters,\n        i,\n        j,\n        k,\n        node,\n        points = [],\n        wordLength,\n        lowerCaseWord = word.toLowerCase(),\n        nodePoints,\n        nodePointsLength,\n        m = Math.max,\n        trie = this.trie,\n        result = [''];\n\n    if (this.exceptions.hasOwnProperty(lowerCaseWord)) {\n        return word.match(this.exceptions[lowerCaseWord]).slice(1);\n    }\n\n    if (word.indexOf('\\u00AD') !== -1) {\n        return [word];\n    }\n\n    word = '_' + word + '_';\n\n    characters = word.toLowerCase().split('');\n    originalCharacters = word.split('');\n    wordLength = characters.length;\n\n    for (i = 0; i < wordLength; i += 1) {\n        points[i] = 0;\n        characterPoints[i] = characters[i].charCodeAt(0);\n    }\n\n    for (i = 0; i < wordLength; i += 1) {\n        node = trie;\n        for (j = i; j < wordLength; j += 1) {\n            node = node[characterPoints[j]];\n\n            if (node) {\n                nodePoints = node._points;\n                if (nodePoints) {\n                    for (k = 0, nodePointsLength = nodePoints.length; k < nodePointsLength; k += 1) {\n                        points[i + k] = m(points[i + k], nodePoints[k]);\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    for (i = 1; i < wordLength - 1; i += 1) {\n        if (i > this.leftMin && i < (wordLength - this.rightMin) && points[i] % 2) {\n            result.push(originalCharacters[i]);\n        } else {\n            result[result.length - 1] += originalCharacters[i];\n        }\n    }\n\n    return result;\n};\n\nmodule.exports = Hypher;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.layoutText = exports.layoutItemsFromString = void 0;\nconst layout_1 = require(\"./layout\");\nfunction layoutItemsFromString(s, measureFn, // <── updated\nhyphenateFn, meta = [] // default to []\n) {\n    const items = [];\n    const chunks = s.split(/(\\s+)/).filter(w => w.length);\n    const spaceWidth = measureFn(' ');\n    const hyphenWidth = measureFn('-');\n    const isSpace = (w) => /\\s/.test(w.charAt(0));\n    const MIN_SPACE = 5.75; // px you never want to go below\n    const shrink = Math.max(0, spaceWidth - MIN_SPACE);\n    let metaIndex = 0; // <- incremented only for words\n    chunks.forEach(w => {\n        if (isSpace(w)) {\n            // plain glue; no meta & no metaIndex++\n            items.push({\n                type: 'glue',\n                width: spaceWidth,\n                shrink: shrink,\n                stretch: spaceWidth * 1.5,\n                text: w\n            });\n            return;\n        }\n        // meta that belongs to THIS word\n        const metaItem = meta[metaIndex++];\n        const pushBox = (txt) => items.push({\n            type: 'box',\n            width: measureFn(txt, metaItem), // <── meta forwarded to measureFn\n            text: txt,\n            meta: metaItem\n        });\n        if (hyphenateFn) {\n            const parts = hyphenateFn(w);\n            parts.forEach((part, j) => {\n                pushBox(part);\n                if (j < parts.length - 1) {\n                    // hyphen penalty: no meta, no measure call\n                    items.push({\n                        type: 'penalty',\n                        width: hyphenWidth,\n                        cost: 10,\n                        flagged: true\n                    });\n                }\n            });\n        }\n        else {\n            pushBox(w);\n        }\n    });\n    // Finishing glue + forced break\n    items.push({ type: 'glue', width: 0, stretch: layout_1.MAX_COST, shrink: 0, text: '' });\n    items.push((0, layout_1.forcedBreak)());\n    return items;\n}\nexports.layoutItemsFromString = layoutItemsFromString;\n/**\n * Helper for laying out a paragraph of text.\n *\n * @param text - The text to lay out\n * @param lineWidth - Width for each line\n * @param measure - Function which is called to measure each word or space in the input\n * @param hyphenate - Function which is called to split words at possible\n* @param meta - A meta object that passes the associated CSS \"classes\" downwards\n * hyphenation points\n */\nfunction layoutText(text, lineWidth, measure, hyphenate, meta) {\n    let items;\n    let breakpoints;\n    let positions;\n    try {\n        items = layoutItemsFromString(text, measure, undefined, meta);\n        breakpoints = (0, layout_1.breakLines)(items, lineWidth, {\n            maxAdjustmentRatio: 1,\n        });\n        positions = (0, layout_1.positionItems)(items, lineWidth, breakpoints);\n    }\n    catch (e) {\n        if (e instanceof layout_1.MaxAdjustmentExceededError) {\n            items = layoutItemsFromString(text, measure, hyphenate, meta);\n            breakpoints = (0, layout_1.breakLines)(items, lineWidth);\n            positions = (0, layout_1.positionItems)(items, lineWidth, breakpoints);\n        }\n        else {\n            throw e;\n        }\n    }\n    return { items, breakpoints, positions };\n}\nexports.layoutText = layoutText;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.justifyContent = exports.unjustifyContent = void 0;\nconst layout_1 = require(\"./layout\");\nconst range_1 = require(\"./util/range\");\nconst dom_text_measurer_1 = __importDefault(require(\"./util/dom-text-measurer\"));\nconst NODE_TAG = 'insertedByTexLinebreak';\n/**\n * Add layout items for `node` to `items`.\n */\nfunction addItemsForTextNode(items, node, measureFn, hyphenateFn) {\n    const text = node.nodeValue;\n    const el = node.parentNode;\n    const spaceWidth = measureFn(el, ' ');\n    const shrink = Math.max(0, spaceWidth - 5.75);\n    const hyphenWidth = measureFn(el, '-');\n    const isSpace = (word) => /\\s/.test(word.charAt(0));\n    const chunks = text.split(/(\\s+)/).filter((w) => w.length > 0);\n    let textOffset = 0;\n    chunks.forEach((w) => {\n        if (isSpace(w)) {\n            const glue = {\n                type: 'glue',\n                width: spaceWidth,\n                shrink,\n                stretch: spaceWidth,\n                node,\n                start: textOffset,\n                end: textOffset + w.length,\n            };\n            items.push(glue);\n            textOffset += w.length;\n            return;\n        }\n        if (hyphenateFn) {\n            const chunks = hyphenateFn(w);\n            chunks.forEach((c, i) => {\n                const box = {\n                    type: 'box',\n                    width: measureFn(el, c),\n                    node,\n                    start: textOffset,\n                    end: textOffset + c.length,\n                };\n                textOffset += c.length;\n                items.push(box);\n                if (i < chunks.length - 1) {\n                    const hyphen = {\n                        type: 'penalty',\n                        width: hyphenWidth,\n                        cost: 10,\n                        flagged: true,\n                        node,\n                        start: textOffset,\n                        end: textOffset,\n                    };\n                    items.push(hyphen);\n                }\n            });\n        }\n        else {\n            const box = {\n                type: 'box',\n                width: measureFn(el, w),\n                node,\n                start: textOffset,\n                end: textOffset + w.length,\n            };\n            textOffset += w.length;\n            items.push(box);\n        }\n    });\n}\n/**\n * Add layout items for `element` and its descendants to `items`.\n */\nfunction addItemsForElement(items, element, measureFn, hyphenateFn) {\n    const { display, width, paddingLeft, paddingRight, marginLeft, marginRight, borderLeftWidth, borderRightWidth, } = getComputedStyle(element);\n    if (display === 'inline') {\n        // Add box for margin/border/padding at start of box.\n        const leftMargin = parseFloat(marginLeft) + parseFloat(borderLeftWidth) + parseFloat(paddingLeft);\n        if (leftMargin > 0) {\n            items.push({ type: 'box', width: leftMargin, node: element, start: 0, end: 0 });\n        }\n        // Add items for child nodes.\n        addItemsForNode(items, element, measureFn, hyphenateFn, false);\n        // Add box for margin/border/padding at end of box.\n        const rightMargin = parseFloat(marginRight) + parseFloat(borderRightWidth) + parseFloat(paddingRight);\n        if (rightMargin > 0) {\n            const length = element.childNodes.length;\n            items.push({ type: 'box', width: rightMargin, node: element, start: length, end: length });\n        }\n    }\n    else {\n        // Treat this item as an opaque box.\n        items.push({\n            type: 'box',\n            width: parseFloat(width),\n            node: element,\n            start: 0,\n            end: 1,\n        });\n    }\n}\n/**\n * Add layout items for input to `breakLines` for `node` to `items`.\n *\n * This function, `addItemsForTextNode` and `addItemsForElement` take an\n * existing array as a first argument to avoid allocating a large number of\n * small arrays.\n */\nfunction addItemsForNode(items, node, measureFn, hyphenateFn, addParagraphEnd = true) {\n    const children = Array.from(node.childNodes);\n    children.forEach((child) => {\n        if (child instanceof Text) {\n            addItemsForTextNode(items, child, measureFn, hyphenateFn);\n        }\n        else if (child instanceof Element) {\n            addItemsForElement(items, child, measureFn, hyphenateFn);\n        }\n    });\n    if (addParagraphEnd) {\n        const end = node.childNodes.length;\n        // Add a synthetic glue that aborbs any left-over space at the end of the\n        // last line.\n        items.push({ type: 'glue', width: 0, shrink: 0, stretch: 1000, node, start: end, end });\n        // Add a forced break to end the paragraph.\n        items.push(Object.assign(Object.assign({}, (0, layout_1.forcedBreak)()), { node, start: end, end }));\n    }\n}\nfunction elementLineWidth(el) {\n    const { width, boxSizing, paddingLeft, paddingRight } = getComputedStyle(el);\n    let w = parseFloat(width);\n    if (boxSizing === 'border-box') {\n        w -= parseFloat(paddingLeft);\n        w -= parseFloat(paddingRight);\n    }\n    return w;\n}\n/**\n * Calculate the actual width of each line and the number of spaces that can be\n * stretched or shrunk to adjust the width.\n */\nfunction lineWidthsAndGlueCounts(items, breakpoints) {\n    const widths = [];\n    const glueCounts = [];\n    for (let b = 0; b < breakpoints.length - 1; b++) {\n        let actualWidth = 0;\n        let glueCount = 0;\n        const start = b === 0 ? breakpoints[b] : breakpoints[b] + 1;\n        for (let p = start; p <= breakpoints[b + 1]; p++) {\n            const item = items[p];\n            if (item.type === 'box') {\n                actualWidth += item.width;\n            }\n            else if (item.type === 'glue' && p !== start && p !== breakpoints[b + 1]) {\n                actualWidth += item.width;\n                ++glueCount;\n            }\n            else if (item.type === 'penalty' && p === breakpoints[b + 1]) {\n                actualWidth += item.width;\n            }\n        }\n        widths.push(actualWidth);\n        glueCounts.push(glueCount);\n    }\n    return [widths, glueCounts];\n}\n/**\n * Mark a node as having been created by `justifyContent`.\n */\nfunction tagNode(node) {\n    node[NODE_TAG] = true;\n}\n/**\n * Return `true` if `node` was created by `justifyContent`.\n */\nfunction isTaggedNode(node) {\n    return node.hasOwnProperty(NODE_TAG);\n}\n/**\n * Return all descendants of `node` created by `justifyContent`.\n */\nfunction taggedChildren(node) {\n    const children = [];\n    for (let i = 0; i < node.childNodes.length; i++) {\n        const child = node.childNodes[i];\n        if (isTaggedNode(child)) {\n            children.push(child);\n        }\n        if (child.childNodes.length > 0) {\n            children.push(...taggedChildren(child));\n        }\n    }\n    return children;\n}\nfunction isTextOrInlineElement(node) {\n    if (node instanceof Text) {\n        return true;\n    }\n    else if (node instanceof Element) {\n        const style = getComputedStyle(node);\n        return style.display === 'inline';\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Wrap text nodes in a range and adjust the inter-word spacing.\n *\n * @param r - The range to wrap\n * @param wordSpacing - The additional spacing to add between words in pixels\n */\nfunction addWordSpacing(r, wordSpacing) {\n    // Collect all text nodes in range, skipping any non-inline elements and\n    // their children because those are treated as opaque blocks by the line-\n    // breaking step.\n    const texts = (0, range_1.textNodesInRange)(r, isTextOrInlineElement);\n    for (let t of texts) {\n        const wrapper = document.createElement('span');\n        tagNode(wrapper);\n        wrapper.style.wordSpacing = `${wordSpacing}px`;\n        t.parentNode.replaceChild(wrapper, t);\n        wrapper.appendChild(t);\n    }\n    return texts;\n}\n/**\n * Reverse the changes made to an element by `justifyContent`.\n */\nfunction unjustifyContent(el) {\n    // Find and remove all elements inserted by `justifyContent`.\n    const tagged = taggedChildren(el);\n    for (let node of tagged) {\n        const parent = node.parentNode;\n        const children = Array.from(node.childNodes);\n        children.forEach((child) => {\n            parent.insertBefore(child, node);\n        });\n        parent.removeChild(node);\n    }\n    // Re-join text nodes that were split by `justifyContent`.\n    el.normalize();\n}\nexports.unjustifyContent = unjustifyContent;\n/**\n * Justify an existing paragraph.\n *\n * Justify the contents of `elements`, using `hyphenateFn` to apply hyphenation if\n * necessary.\n *\n * To justify multiple paragraphs, it is more efficient to call `justifyContent`\n * once with all the elements to be processed, than to call `justifyContent`\n * separately for each element. Passing a list allows `justifyContent` to\n * optimize DOM manipulations.\n */\nfunction justifyContent(elements, hyphenateFn) {\n    // To avoid layout thrashing, we batch DOM layout reads and writes in this\n    // function. ie. we first measure the available width and compute linebreaks\n    // for all elements and then afterwards modify all the elements.\n    if (!Array.isArray(elements)) {\n        elements = [elements];\n    }\n    // Undo the changes made by any previous justification of this content.\n    elements.forEach((el) => {\n        unjustifyContent(el);\n    });\n    // Calculate line-break positions given current element width and content.\n    const measurer = new dom_text_measurer_1.default();\n    const measure = measurer.measure.bind(measurer);\n    const elementBreaks = [];\n    elements.forEach((el) => {\n        const lineWidth = elementLineWidth(el);\n        let items = [];\n        addItemsForNode(items, el, measure);\n        let breakpoints;\n        try {\n            // First try without hyphenation but a maximum stretch-factor for each\n            // space.\n            breakpoints = (0, layout_1.breakLines)(items, lineWidth, {\n                maxAdjustmentRatio: 2.0,\n            });\n        }\n        catch (e) {\n            if (e instanceof layout_1.MaxAdjustmentExceededError) {\n                // Retry with hyphenation and unlimited stretching of each space.\n                items = [];\n                addItemsForNode(items, el, measure, hyphenateFn);\n                breakpoints = (0, layout_1.breakLines)(items, lineWidth);\n            }\n            else {\n                throw e;\n            }\n        }\n        elementBreaks.push({ el, items, breakpoints, lineWidth });\n    });\n    // Insert line-breaks and adjust inter-word spacing.\n    elementBreaks.forEach(({ el, items, breakpoints, lineWidth }) => {\n        const [actualWidths, glueCounts] = lineWidthsAndGlueCounts(items, breakpoints);\n        // Create a `Range` for each line. We create the ranges before modifying the\n        // contents so that node offsets in `items` are still valid at the point when\n        // we create the Range.\n        const endsWithHyphen = [];\n        const lineRanges = [];\n        for (let b = 1; b < breakpoints.length; b++) {\n            const prevBreakItem = items[breakpoints[b - 1]];\n            const breakItem = items[breakpoints[b]];\n            const r = document.createRange();\n            if (b > 1) {\n                r.setStart(prevBreakItem.node, prevBreakItem.end);\n            }\n            else {\n                r.setStart(el, 0);\n            }\n            r.setEnd(breakItem.node, breakItem.start);\n            lineRanges.push(r);\n            endsWithHyphen.push(breakItem.type === 'penalty' && breakItem.flagged);\n        }\n        // Disable automatic line wrap.\n        el.style.whiteSpace = 'nowrap';\n        // Insert linebreaks.\n        lineRanges.forEach((r, i) => {\n            if (i === 0) {\n                return;\n            }\n            const brEl = document.createElement('br');\n            tagNode(brEl);\n            // Insert linebreak. The browser will automatically adjust subsequent\n            // ranges.\n            r.insertNode(brEl);\n            r.setStart(brEl.nextSibling, 0);\n        });\n        // Adjust inter-word spacing on each line and add hyphenation if needed.\n        lineRanges.forEach((r, i) => {\n            const spaceDiff = lineWidth - actualWidths[i];\n            const extraSpacePerGlue = spaceDiff / glueCounts[i];\n            // If this is the final line and the natural spacing between words does\n            // not need to be compressed, then don't try to expand the spacing to fill\n            // the line.\n            const isFinalLine = i === lineRanges.length - 1;\n            if (isFinalLine && extraSpacePerGlue >= 0) {\n                return;\n            }\n            const wrappedNodes = addWordSpacing(r, extraSpacePerGlue);\n            if (endsWithHyphen[i] && wrappedNodes.length > 0) {\n                const lastNode = wrappedNodes[wrappedNodes.length - 1];\n                const hyphen = document.createTextNode('-');\n                tagNode(hyphen);\n                lastNode.parentNode.appendChild(hyphen);\n            }\n        });\n    });\n}\nexports.justifyContent = justifyContent;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createHyphenator = void 0;\nconst hypher_1 = __importDefault(require(\"hypher\"));\n/**\n * Create a hyphenator that uses the given patterns.\n *\n * A wrapper around the `hypher` hyphenation library.\n */\nfunction createHyphenator(patterns) {\n    const hypher = new hypher_1.default(patterns);\n    return (word) => hypher.hyphenate(word);\n}\nexports.createHyphenator = createHyphenator;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./layout\"), exports);\n__exportStar(require(\"./helpers\"), exports);\n__exportStar(require(\"./html\"), exports);\n__exportStar(require(\"./hyphenate\"), exports);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forcedBreak = exports.positionItems = exports.adjustmentRatios = exports.breakLines = exports.MaxAdjustmentExceededError = exports.MAX_COST = exports.MIN_COST = void 0;\n/**\n * Minimum cost for a breakpoint.\n *\n * Values <= `MIN_COST` force a break.\n */\nexports.MIN_COST = -1000;\n/**\n * Maximum cost for a breakpoint.\n *\n * Values >= `MAX_COST` prevent a break.\n */\nexports.MAX_COST = 1000;\nconst MIN_ADJUSTMENT_RATIO = -1;\nfunction isForcedBreak(item) {\n    return item.type === 'penalty' && item.cost <= exports.MIN_COST;\n}\nconst defaultOptions = {\n    maxAdjustmentRatio: null,\n    initialMaxAdjustmentRatio: 1,\n    doubleHyphenPenalty: 0,\n    adjacentLooseTightPenalty: 0,\n};\n/**\n * Error thrown by `breakLines` when `maxAdjustmentRatio` is exceeded.\n */\nclass MaxAdjustmentExceededError extends Error {\n}\nexports.MaxAdjustmentExceededError = MaxAdjustmentExceededError;\n/**\n * Break a paragraph of text into justified lines.\n *\n * Returns the indexes from `items` which have been chosen as breakpoints.\n * `positionBoxes` can be used to generate the X offsets and line numbers of\n * each box using the resulting breakpoints.\n *\n * May throw an `Error` if valid breakpoints cannot be found given the specified\n * adjustment ratio thresholds.\n *\n * The implementation uses the \"TeX algorithm\" from [1].\n *\n * [1] D. E. Knuth and M. F. Plass, “Breaking paragraphs into lines,” Softw.\n *     Pract. Exp., vol. 11, no. 11, pp. 1119–1184, Nov. 1981.\n *\n * @param items - Sequence of box, glue and penalty items to layout.\n * @param lineLengths - Length or lengths of each line.\n */\nfunction breakLines(items, lineLengths, opts = {}) {\n    if (items.length === 0) {\n        return [];\n    }\n    const opts_ = Object.assign(Object.assign({}, defaultOptions), opts);\n    const lineLen = (i) => (Array.isArray(lineLengths) ? lineLengths[i] : lineLengths);\n    const currentMaxAdjustmentRatio = Math.min(opts_.initialMaxAdjustmentRatio, opts_.maxAdjustmentRatio !== null ? opts_.maxAdjustmentRatio : Infinity);\n    const active = new Set();\n    // Add initial active node for beginning of paragraph.\n    active.add({\n        index: 0,\n        line: 0,\n        // Fitness is ignored for this node.\n        fitness: 0,\n        totalWidth: 0,\n        totalStretch: 0,\n        totalShrink: 0,\n        totalDemerits: 0,\n        prev: null,\n    });\n    // Sum of `width` of items up to current item.\n    let sumWidth = 0;\n    // Sum of `stretch` of glue items up to current item.\n    let sumStretch = 0;\n    // Sum of `shrink` of glue items up to current item.\n    let sumShrink = 0;\n    let minAdjustmentRatioAboveThreshold = Infinity;\n    for (let b = 0; b < items.length; b++) {\n        const item = items[b];\n        // TeX allows items with negative widths or stretch factors but imposes two\n        // restrictions for efficiency. These restrictions are not yet implemented\n        // here and we avoid the problem by just disallowing negative\n        // width/shrink/stretch amounts.\n        if (item.width < 0) {\n            throw new Error(`Item ${b} has disallowed negative width`);\n        }\n        // Determine if this is a feasible breakpoint and update `sumWidth`,\n        // `sumStretch` and `sumShrink`.\n        let canBreak = false;\n        if (item.type === 'box') {\n            sumWidth += item.width;\n        }\n        else if (item.type === 'glue') {\n            if (item.shrink < 0 || item.stretch < 0) {\n                throw new Error(`Item ${b} has disallowed negative stretch or shrink`);\n            }\n            canBreak = b > 0 && items[b - 1].type === 'box';\n            if (!canBreak) {\n                sumWidth += item.width;\n                sumShrink += item.shrink;\n                sumStretch += item.stretch;\n            }\n        }\n        else if (item.type === 'penalty') {\n            canBreak = item.cost < exports.MAX_COST;\n        }\n        if (!canBreak) {\n            continue;\n        }\n        // Update the set of active nodes.\n        let lastActive = null;\n        const feasible = [];\n        active.forEach((a) => {\n            // Compute adjustment ratio from `a` to `b`.\n            let adjustmentRatio = 0;\n            const lineShrink = sumShrink - a.totalShrink;\n            const lineStretch = sumStretch - a.totalStretch;\n            const idealLen = lineLen(a.line);\n            let actualLen = sumWidth - a.totalWidth;\n            // Include width of penalty in line length if chosen as a breakpoint.\n            if (item.type === 'penalty') {\n                actualLen += item.width;\n            }\n            // nb. Division by zero produces `Infinity` here, which is what we want.\n            if (actualLen < idealLen) {\n                adjustmentRatio = (idealLen - actualLen) / lineStretch;\n            }\n            else {\n                adjustmentRatio = (idealLen - actualLen) / lineShrink;\n            }\n            if (adjustmentRatio > currentMaxAdjustmentRatio) {\n                // In case we need to try again later with a higher\n                // `maxAdjustmentRatio`, track the minimum value needed to produce\n                // different output.\n                minAdjustmentRatioAboveThreshold = Math.min(adjustmentRatio, minAdjustmentRatioAboveThreshold);\n            }\n            if (adjustmentRatio < MIN_ADJUSTMENT_RATIO || isForcedBreak(item)) {\n                // Items from `a` to `b` cannot fit on one line.\n                active.delete(a);\n                lastActive = a;\n            }\n            if (adjustmentRatio >= MIN_ADJUSTMENT_RATIO && adjustmentRatio <= currentMaxAdjustmentRatio) {\n                // We found a feasible breakpoint. Compute a `demerits` score for it as\n                // per formula on p. 1128.\n                let demerits;\n                const badness = 100 * Math.abs(adjustmentRatio) ** 3;\n                const penalty = item.type === 'penalty' ? item.cost : 0;\n                if (penalty >= 0) {\n                    demerits = (1 + badness + penalty) ** 2;\n                }\n                else if (penalty > exports.MIN_COST) {\n                    demerits = (1 + badness) ** 2 - penalty ** 2;\n                }\n                else {\n                    demerits = (1 + badness) ** 2;\n                }\n                let doubleHyphenPenalty = 0;\n                const prevItem = items[a.index];\n                if (item.type === 'penalty' && prevItem.type === 'penalty') {\n                    if (item.flagged && prevItem.flagged) {\n                        doubleHyphenPenalty = opts_.doubleHyphenPenalty;\n                    }\n                }\n                demerits += doubleHyphenPenalty;\n                // Fitness classes are defined on p. 1155\n                let fitness;\n                if (adjustmentRatio < -0.5) {\n                    fitness = 0;\n                }\n                else if (adjustmentRatio < 0.5) {\n                    fitness = 1;\n                }\n                else if (adjustmentRatio < 1) {\n                    fitness = 2;\n                }\n                else {\n                    fitness = 3;\n                }\n                if (a.index > 0 && Math.abs(fitness - a.fitness) > 1) {\n                    demerits += opts_.adjacentLooseTightPenalty;\n                }\n                // If this breakpoint is followed by glue or non-breakable penalty items\n                // then we don't want to include the width of those when calculating the\n                // width of lines starting after this breakpoint. This is because when\n                // rendering we ignore glue/penalty items at the start of lines.\n                let widthToNextBox = 0;\n                let shrinkToNextBox = 0;\n                let stretchToNextBox = 0;\n                for (let bp = b; bp < items.length; bp++) {\n                    const item = items[bp];\n                    if (item.type === 'box') {\n                        break;\n                    }\n                    if (item.type === 'penalty' && item.cost >= exports.MAX_COST) {\n                        break;\n                    }\n                    widthToNextBox += item.width;\n                    if (item.type === 'glue') {\n                        shrinkToNextBox += item.shrink;\n                        stretchToNextBox += item.stretch;\n                    }\n                }\n                const node = {\n                    index: b,\n                    line: a.line + 1,\n                    fitness,\n                    totalWidth: sumWidth + widthToNextBox,\n                    totalShrink: sumShrink + shrinkToNextBox,\n                    totalStretch: sumStretch + stretchToNextBox,\n                    totalDemerits: a.totalDemerits + demerits,\n                    prev: a,\n                };\n                feasible.push(node);\n            }\n        });\n        // Add feasible breakpoint with lowest score to active set.\n        if (feasible.length > 0) {\n            let bestNode = feasible[0];\n            for (let f of feasible) {\n                if (f.totalDemerits < bestNode.totalDemerits) {\n                    bestNode = f;\n                }\n            }\n            active.add(bestNode);\n        }\n        // Handle situation where there is no way to break the paragraph without\n        // shrinking or stretching a line beyond [-1, currentMaxAdjustmentRatio].\n        if (active.size === 0) {\n            if (isFinite(minAdjustmentRatioAboveThreshold)) {\n                if (opts_.maxAdjustmentRatio === currentMaxAdjustmentRatio) {\n                    throw new MaxAdjustmentExceededError();\n                }\n                // Too much stretching was required for an earlier ignored breakpoint.\n                // Try again with a higher threshold.\n                return breakLines(items, lineLengths, Object.assign(Object.assign({}, opts), { initialMaxAdjustmentRatio: minAdjustmentRatioAboveThreshold * 2 }));\n            }\n            else {\n                // We cannot create a breakpoint sequence by increasing the max\n                // adjustment ratio. This could happen if a box is too wide or there are\n                // glue items with zero stretch/shrink.\n                //\n                // Give up and create a breakpoint at the current position.\n                active.add({\n                    index: b,\n                    line: lastActive.line + 1,\n                    fitness: 1,\n                    totalWidth: sumWidth,\n                    totalShrink: sumShrink,\n                    totalStretch: sumStretch,\n                    totalDemerits: lastActive.totalDemerits + 1000,\n                    prev: lastActive,\n                });\n            }\n        }\n        if (item.type === 'glue') {\n            sumWidth += item.width;\n            sumStretch += item.stretch;\n            sumShrink += item.shrink;\n        }\n    }\n    // Choose active node with fewest total demerits as the last breakpoint.\n    //\n    // There should always be an active node at this point since:\n    //\n    //  1. We add a node to the active set before entering the loop.\n    //  2. Each iteration of the loop either returns from the function, leaves the\n    //     active set unchanged and breaks early or finishes with a non-empty active\n    //     set.\n    let bestNode = null;\n    active.forEach((a) => {\n        if (!bestNode || a.totalDemerits < bestNode.totalDemerits) {\n            bestNode = a;\n        }\n    });\n    // Follow the chain backwards from the chosen node to get the sequence of\n    // chosen breakpoints.\n    const output = [];\n    let next = bestNode;\n    while (next) {\n        output.push(next.index);\n        next = next.prev;\n    }\n    output.reverse();\n    return output;\n}\nexports.breakLines = breakLines;\n/**\n * Compute adjustment ratios for lines given a set of breakpoints.\n *\n * The adjustment ratio of a line is the proportion of each glue item's stretch\n * (if positive) or shrink (if negative) which needs to be used in order to make\n * the line the specified width. A value of zero indicates that every glue item\n * is exactly its preferred width.\n *\n * @param items - The box, glue and penalty items being laid out\n * @param lineLengths - Length or lengths of each line\n * @param breakpoints - Indexes in `items` where lines are being broken\n */\nfunction adjustmentRatios(items, lineLengths, breakpoints) {\n    const lineLen = (i) => (Array.isArray(lineLengths) ? lineLengths[i] : lineLengths);\n    const ratios = [];\n    for (let b = 0; b < breakpoints.length - 1; b++) {\n        let idealWidth = lineLen(b);\n        let actualWidth = 0;\n        let lineShrink = 0;\n        let lineStretch = 0;\n        const start = b === 0 ? breakpoints[b] : breakpoints[b] + 1;\n        for (let p = start; p <= breakpoints[b + 1]; p++) {\n            const item = items[p];\n            if (item.type === 'box') {\n                actualWidth += item.width;\n            }\n            else if (item.type === 'glue' && p !== start && p !== breakpoints[b + 1]) {\n                actualWidth += item.width;\n                lineShrink += item.shrink;\n                lineStretch += item.stretch;\n            }\n            else if (item.type === 'penalty' && p === breakpoints[b + 1]) {\n                actualWidth += item.width;\n            }\n        }\n        let adjustmentRatio;\n        if (actualWidth < idealWidth) {\n            adjustmentRatio = (idealWidth - actualWidth) / lineStretch;\n        }\n        else {\n            adjustmentRatio = (idealWidth - actualWidth) / lineShrink;\n        }\n        ratios.push(adjustmentRatio);\n    }\n    return ratios;\n}\nexports.adjustmentRatios = adjustmentRatios;\n/**\n * Compute the positions at which to draw boxes forming a paragraph given a set\n * of breakpoints.\n *\n * @param items - The sequence of items that form the paragraph.\n * @param lineLengths - Length or lengths of each line.\n * @param breakpoints - Indexes within `items` of the start of each line.\n */\nfunction positionItems(items, lineLengths, breakpoints, options = {}) {\n    const adjRatios = adjustmentRatios(items, lineLengths, breakpoints);\n    const result = [];\n    for (let b = 0; b < breakpoints.length - 1; b++) {\n        // Limit the amount of shrinking of lines to 1x `glue.shrink` for each glue\n        // item in a line.\n        const adjustmentRatio = Math.max(adjRatios[b], MIN_ADJUSTMENT_RATIO);\n        let xOffset = 0;\n        const start = b === 0 ? breakpoints[b] : breakpoints[b] + 1;\n        for (let p = start; p <= breakpoints[b + 1]; p++) {\n            const item = items[p];\n            if (item.type === 'box') {\n                result.push({\n                    item: p,\n                    line: b,\n                    xOffset,\n                    width: item.width,\n                });\n                xOffset += item.width;\n            }\n            else if (item.type === 'glue' && p !== start && p !== breakpoints[b + 1]) {\n                let gap;\n                if (adjustmentRatio < 0) {\n                    gap = item.width + adjustmentRatio * item.shrink;\n                }\n                else {\n                    gap = item.width + adjustmentRatio * item.stretch;\n                }\n                if (options.includeGlue) {\n                    result.push({\n                        item: p,\n                        line: b,\n                        xOffset,\n                        width: gap,\n                    });\n                }\n                xOffset += gap;\n            }\n            else if (item.type === 'penalty' && p === breakpoints[b + 1] && item.width > 0) {\n                result.push({\n                    item: p,\n                    line: b,\n                    xOffset,\n                    width: item.width,\n                });\n            }\n        }\n    }\n    return result;\n}\nexports.positionItems = positionItems;\n/**\n * Return a `Penalty` item which forces a line-break.\n */\nfunction forcedBreak() {\n    return { type: 'penalty', cost: exports.MIN_COST, width: 0, flagged: false };\n}\nexports.forcedBreak = forcedBreak;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass TextMetricsCache {\n    constructor() {\n        this._fonts = new Map();\n        this._textWidths = new Map();\n    }\n    putFont(el, cssFont) {\n        this._fonts.set(el, cssFont);\n    }\n    cssFontForElement(el) {\n        return this._fonts.get(el);\n    }\n    putWidth(cssFont, word, width) {\n        let widths = this._textWidths.get(cssFont);\n        if (!widths) {\n            widths = new Map();\n            this._textWidths.set(cssFont, widths);\n        }\n        widths.set(word, width);\n    }\n    getWidth(cssFont, word) {\n        const widths = this._textWidths.get(cssFont);\n        if (!widths) {\n            return null;\n        }\n        return widths.get(word);\n    }\n}\n/**\n * Return the computed CSS `font` property value for an element.\n */\nfunction cssFontForElement(el) {\n    const style = getComputedStyle(el);\n    // Safari and Chrome can synthesize a value for `font` for us.\n    let font = style.font;\n    if (font.length > 0) {\n        return font;\n    }\n    // Fall back to generating CSS font property value if browser (eg. Firefox)\n    // does not synthesize it automatically.\n    const { fontStyle, fontVariant, fontWeight, fontSize, fontFamily } = style;\n    font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize} ${fontFamily}`;\n    return font;\n}\nlet measureCtx;\n/**\n * Measure the width of `text` as it would appear if rendered within an\n * `Element` with a given computed `font` style.\n */\nfunction measureText(cssFont, text) {\n    if (!measureCtx) {\n        const canvas = document.createElement('canvas');\n        measureCtx = canvas.getContext('2d');\n    }\n    // Capture as much of the style as possible. Note that some properties such\n    // as `font-stretch`, `font-size-adjust` and `font-kerning` are not settable\n    // through the CSS `font` property.\n    //\n    // Apparently in some browsers the canvas context's text style inherits\n    // style properties from the `<canvas>` element.\n    // See https://stackoverflow.com/a/8955835/434243\n    measureCtx.font = cssFont;\n    return measureCtx.measureText(text).width;\n}\n/** Measure the width of pieces of text in the DOM, with caching. */\nclass DOMTextMeasurer {\n    constructor() {\n        this._cache = new TextMetricsCache();\n    }\n    /**\n     * Return the width of `text` rendered by a `Text` node child of `context`.\n     */\n    measure(context, text) {\n        let cssFont = this._cache.cssFontForElement(context);\n        if (!cssFont) {\n            cssFont = cssFontForElement(context);\n            this._cache.putFont(context, cssFont);\n        }\n        let width = this._cache.getWidth(cssFont, text);\n        if (!width) {\n            width = measureText(cssFont, text);\n            this._cache.putWidth(cssFont, text, width);\n        }\n        return width;\n    }\n}\nexports.default = DOMTextMeasurer;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.textNodesInRange = void 0;\n/**\n * Return a list of `Text` nodes in `range`.\n *\n * `filter` is called with each node in document order in the subtree rooted\n * at `range.commonAncestorContainer`. If it returns false, that node and its\n * children are skipped.\n */\nfunction textNodesInRange(range, filter) {\n    const root = range.commonAncestorContainer;\n    const nodeIter = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ALL, {\n        acceptNode(node) {\n            if (filter(node)) {\n                return NodeFilter.FILTER_ACCEPT;\n            }\n            else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        },\n    }, \n    // @ts-expect-error - Extra argument for IE 11 / Legacy Edge\n    false /* expandEntityReferences */);\n    let currentNode = nodeIter.currentNode;\n    let foundStart = false;\n    let nodes = [];\n    while (currentNode) {\n        if (range.intersectsNode(currentNode) && currentNode instanceof Text) {\n            nodes.push(currentNode);\n        }\n        currentNode = nodeIter.nextNode();\n    }\n    return nodes;\n}\nexports.textNodesInRange = textNodesInRange;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n",""],"names":[],"sourceRoot":""}